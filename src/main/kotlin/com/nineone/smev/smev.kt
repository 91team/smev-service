package com.nineone.smev

import org.apache.xml.security.utils.resolver.ResourceResolver
import org.w3c.dom.Document
import org.w3c.dom.Element
import org.xml.sax.InputSource
import ru.it.smev.message_exchange.autogenerated.service.v1_3.SMEVMessageExchangePortType
import ru.it.smev.message_exchange.autogenerated.service.v1_3.SMEVMessageExchangeService
import ru.it.smev.message_exchange.autogenerated.types.basic.v1_3.*
import ru.it.smev.message_exchange.autogenerated.types.v1_3.*
import ru.voskhod.crypto.XMLTransformHelper
import ru.voskhod.smev.client.api.identification.impl.IdentificationServiceImpl
import ru.voskhod.smev.client.api.services.signature.Signer
import ru.voskhod.smev.client.api.services.template.configuration.MTOMAttachmentTemplateConfiguration
import ru.voskhod.smev.client.api.signature.configuration.SignatureConfigurationImpl
import ru.voskhod.smev.client.api.signature.impl.SignerImpl
import ru.voskhod.smev.client.api.template.impl.MTOMAttachmentTemplateImpl
import ru.voskhod.smev.client.api.types.exception.SMEVRuntimeException
import ru.voskhod.smev.client.api.types.exception.processing.SMEVSignatureException
import java.io.ByteArrayOutputStream
import java.io.File
import java.io.IOException
import java.io.StringReader
import java.net.URL
import java.time.LocalDateTime
import javax.activation.DataHandler
import javax.activation.FileDataSource
import javax.xml.bind.JAXBContext
import javax.xml.bind.JAXBException
import javax.xml.bind.Marshaller
import javax.xml.datatype.DatatypeFactory
import javax.xml.namespace.QName
import javax.xml.parsers.DocumentBuilderFactory

class SMEVService(schemaUrl: String?, // точка доступа СМЭВ 3
                  keyAlias: String,
                  keyPassword: String,
                  private val isTest: Boolean = false,
                  soapServiceName: String?,
                  soapEndpointName: String?,
                  private val prettyPrint: Boolean = false
) {
    private val schemaUrl = URL(schemaUrl ?: "http://172.20.3.12:5000/ws/smev-message-exchange-service-1.3.wsdl")
    private val smevNamespaceUri: String = "urn://x-artefacts-smev-gov-ru/services/message-exchange/1.3"
    private val soapServiceQname: QName = QName(smevNamespaceUri, soapServiceName ?: "SMEVMessageExchangeService")
    private val soapEndpointQname: QName = QName(smevNamespaceUri, soapEndpointName ?: "SMEVMessageExchangeEndpoint")
    private var sign: Signer

    init {
        val signConfig = SignatureConfigurationImpl("JCP2", keyAlias, keyAlias, keyPassword, null)
        sign = SignerImpl(signConfig)
        sign.init(keyAlias, keyAlias, keyPassword)
//        JCPXMLDSigInit.init()
        ResourceResolver.registerAtStart("ru.CryptoPro.JCPxml.utility.DocumentIdResolver")
    }

    @Throws(Exception::class)
    fun sendRequest(message: String) {
        val files = listOf<File>(
//            File("files/applicationDescriptionSmev3.doc")
        )

        val sendReq = SenderProvidedRequestData().apply {
            id = "SIGNED_BY_CALLER"
            messageID = IdentificationServiceImpl().generateUUID()
            testMessage = Void().takeIf { isTest }
            // nodeID("421")
            messagePrimaryContent = MessagePrimaryContent().apply { any = buildMessage(message) }
            attachmentHeaderList = buildAttachmentsHeaders(sign, files)
        }

        val reqParam = SendRequestRequest().apply {
            senderProvidedRequestData = sendReq
            callerInformationSystemSignature = signElement(senderProvidedRequestData)
            attachmentContentList = buildAttachments(files)

            println("request = " + objectToString(this))
        }

        val smev = SMEVMessageExchangeService(schemaUrl, soapServiceQname)
        try {
            val port = smev.getPort(soapEndpointQname, SMEVMessageExchangePortType::class.java)
            port.sendRequest(reqParam).run { println("resp = " + objectToString(this)) }
        } catch (e: java.lang.Exception) {
            println("ERROR ${e.javaClass.name}: ${e.message}")
        }
    }

    @Throws(Exception::class)
    fun getResponse() {
        val message = MessageTypeSelector().apply {
            id = "SIGNED_BY_CALLER"
            timestamp = DatatypeFactory.newInstance().newXMLGregorianCalendar(LocalDateTime.now().toString())
        }

        val reqParam = GetResponseRequest().apply {
            messageTypeSelector = message
            callerInformationSystemSignature = signElement(messageTypeSelector)

            println("request = " + objectToString(this))
        }

        val smev = SMEVMessageExchangeService(schemaUrl, soapServiceQname)
        try {
            val port = smev.getPort(soapEndpointQname, SMEVMessageExchangePortType::class.java)
            port.getResponse(reqParam).apply {
                println("resp = " + objectToString(this))
                responseMessage?.response?.messageMetadata?.messageId?.let { sendAck(it) }
            }
        } catch (e: java.lang.Exception) {
            println("ERROR ${e.javaClass.name}: ${e.message}")
        }
    }

    @Throws(Exception::class)
    fun sendAck(messageId: String, accepted: Boolean = true) {
        val message = AckTargetMessage().apply {
            id = "SIGNED_BY_CALLER"
            isAccepted = accepted
            value = messageId
        }

        val reqParam = AckRequest().apply {
            ackTargetMessage = message
            callerInformationSystemSignature = signElement(ackTargetMessage)

            println("request = " + objectToString(this))
        }

        val smev = SMEVMessageExchangeService(schemaUrl, soapServiceQname)
        try {
            val port = smev.getPort(soapEndpointQname, SMEVMessageExchangePortType::class.java)
            port.ack(reqParam)
        } catch (e: java.lang.Exception) {
            println("ERROR ${e.javaClass.name}: ${e.message}")
        }
    }

    private fun signElement(data: Any): XMLDSigSignatureType {
        return XMLDSigSignatureType().apply { any = sign.sign(objectToDocument(data).documentElement) }
    }

    private fun buildMessage(data: String): Element {
         return DocumentBuilderFactory
             .newInstance().apply { isNamespaceAware = true }
             .newDocumentBuilder()
             .parse(InputSource(StringReader(data)))
             .documentElement
    }

    @Throws(IOException::class)
    fun buildAttachments(files: List<File>): AttachmentContentList? {
        if (files.isEmpty()) return null
        return AttachmentContentList().also {
             files.forEach { file ->
                 it.attachmentContent.add(AttachmentContentType().apply {
                    DataHandler(FileDataSource(file)).also { dataHandler ->
                        content = dataHandler
                        id = dataHandler.name
                    }
                })
            }
        }
    }

    @Throws(SMEVSignatureException::class, SMEVRuntimeException::class)
    fun buildAttachmentsHeaders(signer: Signer, files: List<File>): AttachmentHeaderList? {
        if (files.isEmpty()) return null
        val attachmentHeader = AttachmentHeaderList()
        val attachments = MTOMAttachmentTemplateImpl<MTOMAttachmentTemplateConfiguration>(signer, IdentificationServiceImpl()).createAttachments(files)
        attachments.forEach {
            attachmentHeader.attachmentHeader.add(AttachmentHeaderType().apply {
                contentId = it.attachmentId
                mimeType = it.mimeType
                signaturePKCS7 = it.signaturePKCS7
            })
        }
        return attachmentHeader
    }

    @Throws(JAXBException::class, IOException::class)
    private fun objectToString(obj: Any): String {
        val baos = ByteArrayOutputStream()
        val jaxbMarshaller = JAXBContext.newInstance(obj::class.java).createMarshaller()
        jaxbMarshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, prettyPrint)
        jaxbMarshaller.marshal(obj, baos)
        return baos.toString().also { baos.close() }
    }

    @Throws(JAXBException::class, IOException::class)
    fun objectToDocument(obj: Any): Document = XMLTransformHelper.buildDocumentFromString(objectToString(obj))
}