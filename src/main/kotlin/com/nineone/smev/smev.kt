package com.nineone.smev

import org.w3c.dom.Document
import org.w3c.dom.Element
// import org.w3c.dom.NodeList
// import org.w3c.dom.NodeList
import org.xml.sax.InputSource
import ru.it.smev.message_exchange.autogenerated.types.basic.v1_3.*
import ru.it.smev.message_exchange.autogenerated.service.v1_3.SMEVMessageExchangeService
import ru.it.smev.message_exchange.autogenerated.service.v1_3.SMEVMessageExchangePortType
import ru.it.smev.message_exchange.autogenerated.types.v1_3.*

import ru.voskhod.crypto.XMLTransformHelper
import ru.voskhod.smev.client.api.identification.impl.IdentificationServiceImpl
import ru.voskhod.smev.client.api.services.identification.IdentityService
import ru.voskhod.smev.client.api.services.signature.Signer
import ru.voskhod.smev.client.api.signature.configuration.SignatureConfigurationImpl
import ru.voskhod.smev.client.api.signature.impl.SignerImpl
import java.io.ByteArrayOutputStream
import java.io.IOException
import java.io.StringReader
import java.net.URL
import java.time.LocalDateTime
import javax.xml.bind.JAXBContext
import javax.xml.bind.JAXBException
import javax.xml.bind.Marshaller
import javax.xml.datatype.DatatypeFactory
import javax.xml.namespace.QName
import javax.xml.parsers.DocumentBuilder
import javax.xml.parsers.DocumentBuilderFactory

class SMEVService(schemaUrl: String, //указывается точка доступа СМЭВ 3
                  keyAlias: String, // наименование хранилища JCP
                  keyPassword: String, //пароль от хранилища
                  private val isTest: Boolean = false,
                  private val soapServiceName: String = "SMEVMessageExchangeService",
                  private val soapEndpointName: String = "SMEVMessageExchangeEndpoint"
) {
    private val schemaUrl = URL(schemaUrl)
    private val smevNamespaceUri: String = "urn://x-artefacts-smev-gov-ru/services/message-exchange/1.3"
    private val soapServiceQname: QName = QName(smevNamespaceUri, soapServiceName)
    private val soapEndpointQname: QName = QName(smevNamespaceUri, soapEndpointName)
    private var sign: Signer

    init {
        // Инициализация хранилища сертификатов и создание конфигурации для подписи
        val signConfig = SignatureConfigurationImpl("JCP2", keyAlias, keyAlias, keyPassword, null)
        sign = SignerImpl(signConfig)
        sign.init(keyAlias, keyAlias, keyPassword) //инициализация конфигурации подписи
    }

    @Throws(Exception::class)
    fun sendRequest() {
        // Создание нового экземпляра запроса
        val reqParam = SendRequestRequest()
        val sendReq = SenderProvidedRequestData()
        sendReq.id = "SIGNED_BY_CALLER" // id подписи
        val messageId: IdentityService = IdentificationServiceImpl()
        sendReq.messageID = messageId.generateUUID() // messageId запроса
        //2.1 формирование запроса сведения
        val messagecontent = MessagePrimaryContent()
        // сведение, которое необходимо передать
        val contentString = """<fedstat:PublicRequest xmlns:fedstat="urn://x-artefacts-fedstat-ru/services/public/1.0.5"><fedstat:ClassifiersRequest/></fedstat:PublicRequest>"""
        val content: Element
        val factory: DocumentBuilderFactory = DocumentBuilderFactory.newInstance()
        factory.isNamespaceAware = true
        val builder: DocumentBuilder = factory.newDocumentBuilder()
        val document: Document = builder.parse(InputSource(StringReader(contentString)))
        content = document.documentElement
        messagecontent.any = content
        sendReq.messagePrimaryContent = messagecontent
        if (this.isTest) sendReq.testMessage = Void() //признак тестового сообщения
        //        sendReq.setNodeID("421"); //имя ноды(необязательно)
        reqParam.senderProvidedRequestData = sendReq
        //2.4 Подпись запроса
        val content1: Element = objectToDocument(
            reqParam.senderProvidedRequestData,
            SenderProvidedRequestData::class.java
        ).documentElement
        val signElement: Element = sign.sign(content1)
        val xmlSign = XMLDSigSignatureType()
        xmlSign.any = signElement
        reqParam.callerInformationSystemSignature = xmlSign
        //выводится подписанный запрос *********************
        println("request = " + objectToString(reqParam, SendRequestRequest::class.java))
        //*************************************
//        val doc: Document = objectToString(reqParam, SendRequestRequest::class.java)
//        val messCont: NodeList = doc.documentElement.getElementsByTagNameNS("*", "MessagePrimaryContent")
        // 3. Отправка сообщения в СМЭВ 3
        val smev = SMEVMessageExchangeService(schemaUrl, soapServiceQname)
        try {
            val port = smev.getPort(soapEndpointQname, SMEVMessageExchangePortType::class.java)
            val resp: SendRequestResponse = port.sendRequest(reqParam)
            println("resp = " + objectToString(resp, SendRequestResponse::class.java))
        } catch (e: java.lang.Exception) {
            println("ERROR ${e.javaClass.name}: ${e.message}")
        }
    }

    @Throws(Exception::class)
    fun getResponse() {
        // Создание нового экземпляра запроса
        val reqParam = GetResponseRequest()

        val messageTypeSelector = MessageTypeSelector()
        messageTypeSelector.id = "SIGNED_BY_CALLER"
        messageTypeSelector.timestamp = DatatypeFactory.newInstance().newXMLGregorianCalendar(LocalDateTime.now().toString())

        reqParam.messageTypeSelector = messageTypeSelector

        val xmlSign = XMLDSigSignatureType()
        val signContent: Element = objectToDocument(
            reqParam.messageTypeSelector,
            MessageTypeSelector::class.java
        ).documentElement
        val signElement: Element = sign.sign(signContent)
        xmlSign.any = signElement
        reqParam.callerInformationSystemSignature = xmlSign
        // выводится подписанный запрос
        println("request = " + objectToString(reqParam, GetResponseRequest::class.java))
        // 3. Отправка сообщения в СМЭВ 3
        val smev = SMEVMessageExchangeService(schemaUrl, soapServiceQname)
        try {
            val port = smev.getPort(soapEndpointQname, SMEVMessageExchangePortType::class.java)
            val resp: GetResponseResponse = port.getResponse(reqParam)
            println("resp = " + objectToString(resp, GetResponseResponse::class.java))
            resp?.responseMessage?.response?.messageMetadata?.messageId?.let { sendAck(it) }
        } catch (e: java.lang.Exception) {
            println("ERROR ${e.javaClass.name}: ${e.message}")
        }
    }


    @Throws(Exception::class)
    fun sendAck(messageId: String, accepted: Boolean = true) {
        // Создание нового экземпляра запроса
        val reqParam = AckRequest()

        val ackMessage = AckTargetMessage()
        ackMessage.id = "SIGNED_BY_CALLER"
        ackMessage.isAccepted = accepted
        ackMessage.value = messageId

        reqParam.ackTargetMessage = ackMessage

        val xmlSign = XMLDSigSignatureType()
        val signContent: Element = objectToDocument(
            reqParam.ackTargetMessage,
            AckTargetMessage::class.java
        ).documentElement
        val signElement: Element = sign.sign(signContent)
        xmlSign.any = signElement
        reqParam.callerInformationSystemSignature = xmlSign
        // выводится подписанный запрос
        println("request = " + objectToString(reqParam, AckRequest::class.java))
        // 3. Отправка сообщения в СМЭВ 3
        val smev = SMEVMessageExchangeService(schemaUrl, soapServiceQname)
        try {
            val port = smev.getPort(soapEndpointQname, SMEVMessageExchangePortType::class.java)
            port.ack(reqParam)
        } catch (e: java.lang.Exception) {
            println("ERROR ${e.javaClass.name}: ${e.message}")
        }
    }

    @Throws(JAXBException::class, IOException::class)
    private fun objectToString(obj: Any, className: Any): String {
        val jaxbContext: JAXBContext = JAXBContext.newInstance(className as Class<*>)
        val jaxbMarshaller: Marshaller = jaxbContext.createMarshaller()
        //        jaxbMarshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
        val baos = ByteArrayOutputStream()
        jaxbMarshaller.marshal(obj, baos)
        val content: String = baos.toString()
        baos.close()
        return content
    }

    @Throws(JAXBException::class, IOException::class)
    fun objectToDocument(obj: Any, className: Any): Document {
        val jaxbContext: JAXBContext = JAXBContext.newInstance(className as Class<*>)
        val jaxbMarshaller: Marshaller = jaxbContext.createMarshaller()
        //        jaxbMarshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
        val baos = ByteArrayOutputStream()
        jaxbMarshaller.marshal(obj, baos)
        val content: Document = XMLTransformHelper.buildDocumentFromString(baos.toString())
        baos.close()
        return content
    }
}