import org.w3c.dom.Document
import org.w3c.dom.Element
import org.w3c.dom.NodeList
import org.xml.sax.InputSource
import ru.it.smev.message_exchange.autogenerated.types.basic.v1_3.*
import ru.it.smev.message_exchange.autogenerated.types.v1_3.SendRequestRequest
import ru.it.smev.message_exchange.autogenerated.types.v1_3.SendRequestResponse
import ru.it.smev.message_exchange.autogenerated.types.v1_3.SenderProvidedRequestData
import ru.it.smev.message_exchange.autogenerated.service.v1_3.SMEVMessageExchangeService

import ru.voskhod.crypto.XMLTransformHelper
import ru.voskhod.smev.client.api.identification.impl.IdentificationServiceImpl
import ru.voskhod.smev.client.api.services.identification.IdentityService
import ru.voskhod.smev.client.api.services.signature.Signer
import ru.voskhod.smev.client.api.signature.configuration.SignatureConfigurationImpl
import ru.voskhod.smev.client.api.signature.impl.SignerImpl
import java.io.ByteArrayOutputStream
import java.io.IOException
import java.io.StringReader
import java.net.URL
import javax.xml.bind.JAXBContext
import javax.xml.bind.JAXBException
import javax.xml.bind.Marshaller
import javax.xml.namespace.QName
import javax.xml.parsers.DocumentBuilder
import javax.xml.parsers.DocumentBuilderFactory

object Smev {
    private const val smev_url =
        "http://smev3-n0.test.gosuslugi.ru:5000/ws/smev-message-exchange-service-1.3.wsdl" //указывается точка доступа СМЭВ 3
    private const val alias_smev = "skspb" //наименование хранилища JCP
    private const val alias_key = "1234567890" //пароль от хранилища
    private val SMEVMESSAGEEXCHANGESERVICE_QNAME: QName =
        QName("urn://x-artefacts-smev-gov-ru/services/message-exchange/1.3", "SMEVMessageExchangeService")

    @Throws(Exception::class)
    fun run() {
        //1. Инициализация хранилища сертификатов
        // создается конфигурация для подписи
        val signConfig = SignatureConfigurationImpl("JCP2", alias_smev, alias_smev, alias_key, null)
        val sign: Signer = SignerImpl(signConfig)
        sign.init(alias_smev, alias_smev, alias_key) //инициализация конфигурации подписи
        //2.создание нового экземпляра запроса
        val reqParam = SendRequestRequest()
        val sendReq = SenderProvidedRequestData()
        sendReq.id = "signature-id" // id подписи
        val messageId: IdentityService = IdentificationServiceImpl()
        sendReq.messageID = messageId.generateUUID() // messageId запроса
        //2.1 формирование запроса сведения
        val messagecontent = MessagePrimaryContent()
        // сведение, которое необходимо передать
        val contentString = """<ns:SendLetterRequest
        xmlns:ns="urn://x-artefacts-russianpost-erl-ru/send-letter/1.0.0"
        xmlns:ns1="urn://x-artefacts-russianpost-erl-ru/send-letter/types/1.0.0">
    <ns1:customerInfo>
        <ns1:id>1</ns1:id>
        <ns1:token>1991f9fc-b2d1-421a-a60e-74fc326ecd6d</ns1:token>
    </ns1:customerInfo>
    <ns1:letterInfo>
        <ns1:mailRank>4</ns1:mailRank>
        <ns1:type>REGISTERED</ns1:type>
        <ns1:attachments>
            <ns1:customerSpecificInfo attachmentId="attachmentIdInSOAPMessage"/>
            <ns1:pdfBasedLetter attachmentId="pdfAttachmentIdInSOAPMessage" />
        </ns1:attachments>
    </ns1:letterInfo>
    <ns1:sendingDocument>
        <ns1:id>11#112233</ns1:id>
        <ns1:regDate>2016-05-31T16:35:11.000+03:00</ns1:regDate>
        <ns1:regNum>11#112233</ns1:regNum>
        <ns1:payment>
            <ns1:bankName>String</ns1:bankName>
            <ns1:operatingAccount>12345678901234567890</ns1:operatingAccount>
            <ns1:BIK>123456789</ns1:BIK>
            <ns1:INN>1234567890</ns1:INN>
            <ns1:KPP>123456789</ns1:KPP>
            <ns1:KBK>12345678901234567890</ns1:KBK>
            <ns1:OKTMO>12345678</ns1:OKTMO>
            <ns1:paymentName>String</ns1:paymentName>
            <ns1:recipientName>String</ns1:recipientName>
            <ns1:UIN>1234567890123456789012345</ns1:UIN>
            <ns1:amount>1000000</ns1:amount>
            <ns1:paymentPeriod>60</ns1:paymentPeriod>
        </ns1:payment>
    </ns1:sendingDocument>
    <ns1:sender>
        <ns1:departmentName>String</ns1:departmentName>
    </ns1:sender>
    <ns1:recipient>
        <ns1:сountryCodeOKSM>643</ns1:сountryCodeOKSM>
        <ns1:address>String</ns1:address>
        <ns1:legalPerson>
            <ns1:orgName>String</ns1:orgName>
        </ns1:legalPerson>
    </ns1:recipient>
</ns:SendLetterRequest>"""
        val content: Element
        val factory: DocumentBuilderFactory = DocumentBuilderFactory.newInstance()
        factory.isNamespaceAware = true
        val builder: DocumentBuilder = factory.newDocumentBuilder()
        val document: Document = builder.parse(InputSource(StringReader(contentString)))
        content = document.documentElement
        messagecontent.any = content
        sendReq.messagePrimaryContent = messagecontent
        sendReq.testMessage = Void() //признак тестового сообщения
        //        sendReq.setNodeID("421"); //имя ноды(необязательно)
        reqParam.senderProvidedRequestData = sendReq
        //2.4 Подпись запроса
        val content1: Element = ObjectToDocument(
            reqParam.senderProvidedRequestData,
            SenderProvidedRequestData::class.java
        ).documentElement
        val signElement: Element = sign.sign(content1)
        val xmlSign = XMLDSigSignatureType()
        xmlSign.any = signElement
        reqParam.callerInformationSystemSignature = xmlSign
        //выводится подписанный запрос *********************
        println("request = " + ObjectToString(reqParam, SendRequestRequest::class.java))
        //*************************************
        val doc: Document = ObjectToDocument(reqParam, SendRequestRequest::class.java)
        val messCont: NodeList = doc.documentElement.getElementsByTagNameNS("*", "MessagePrimaryContent")
        // 3. Отправка сообщения в СМЭВ 3
        val smev = SMEVMessageExchangeService(URL(smev_url), SMEVMESSAGEEXCHANGESERVICE_QNAME)
        try {
            val resp: SendRequestResponse = smev.smevMessageExchangeEndpoint.sendRequest(reqParam)
            println("resp = " + ObjectToString(resp, SendRequestResponse::class.java))
        } catch (ex: java.lang.Exception) {
            println("ex = " + ex.message)
        }
    }

    @Throws(JAXBException::class, IOException::class)
    private fun ObjectToString(obj: Any, className: Any): String {
        val jaxbContext: JAXBContext = JAXBContext.newInstance(className as Class<*>)
        val jaxbMarshaller: Marshaller = jaxbContext.createMarshaller()
        //        jaxbMarshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
        val baos = ByteArrayOutputStream()
        jaxbMarshaller.marshal(obj, baos)
        val content: String = baos.toString()
        baos.close()
        return content
    }

    @Throws(JAXBException::class, IOException::class)
    fun ObjectToDocument(obj: Any, className: Any): Document {
        val jaxbContext: JAXBContext = JAXBContext.newInstance(className as Class<*>)
        val jaxbMarshaller: Marshaller = jaxbContext.createMarshaller()
        //        jaxbMarshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
        val baos = ByteArrayOutputStream()
        jaxbMarshaller.marshal(obj, baos)
        val content: Document = XMLTransformHelper.buildDocumentFromString(baos.toString())
        baos.close()
        return content
    }
}